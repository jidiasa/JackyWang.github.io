<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Webpage</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
        }
        h1, h2 {
            text-align: center;
            color: #333;
        }
        .code-section, .result-section, .project-section {
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            max-width: 800px;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px 0;
        }
        a {
            display: inline-block;
            margin-top: 10px;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        a:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

    <h1>Project 1 by Tianhe Wang</h1>

    <!-- Project Description Section -->
    <div class="project-section">
        <h2>Project Description</h2>
        <p>
            This project is Project 1 of the CS180 course. The project involves cropping, aligning, and displaying three RGB images using the following methods:
        </p>
        <ol>
            <li>
                <strong>Data Preprocessing:</strong> The images are imported and cropped along their height into three parts, each corresponding to one of the BGR color channels. To improve alignment accuracy, border detection and cropping are performed. Borders are identified and cropped if their color values are too white (>0.98) or too dark (<0.02), while ensuring that all three images have the same dimensions after cropping.
            </li>
            <li>
                <strong>Image Alignment:</strong> The R and G images are aligned with the B image. The distance between images is measured using the NCC (Normalized Cross-Correlation) function.
                <ul>
                    <li>For .jpg images, a direct search method is used. A pixel-by-pixel search is performed within a displacement range of (-15, 15) until the best match is found.</li>
                    <li>For larger .tif images, a pyramid algorithm is used. Each layer of the image is blurred and sampled every factor = 2. Gaussian blur is applied, where each pixel is a weighted sum of its surrounding pixels. The process is repeated until fewer than 64 pixels remain. Then, the best match is searched from small to large layers, with displacement multiplied by the scaling factor to achieve a coarse-to-fine search.</li>
                </ul>
            </li>
            <li>
                <strong>Image Composition:</strong> Based on the obtained displacements, only the overlapping regions of the three images are extracted and cropped. The resulting image is then converted into a color image with values from 0 to 255.
            </li>
        </ol>
        <p>
            The results show that the images are well-aligned with minimal ghosting and proper border cropping, achieving the task objectives. Although the .tif images are much larger than the .jpg images, the pyramid algorithm significantly reduced the runtime and expanded the search range.
        </p>
        <p>
            A drawback is that ghosting is not completely eliminated; some ghosting is still visible under magnification (eg. emir, melons), indicating that the best match has not been obtained. This may be due to the NCC distance calculation method, as using `np.roll` for NCC calculation affects the result by including surrounding pixels. Additionally, NCC itself may have limitations, as it might struggle with images containing objects with contrasting colors against backgrounds. Consideration of alternative image distance matching algorithms may be needed.
        </p>
    </div>

    <!-- Section to show link to Python code files -->
    <div class="code-section">
        <h2>Python Code</h2>
        <p>You can view or download the Python code by clicking the links below:</p>
        <a href="colorize_skel.py" download>Download main.py</a>
        <a href="colorize_all.py" download>Download colorize_all.py</a>
        <a href="image_py_Gaussian.py" download>Download image_py_Gaussian.py</a>
        <a href="search.py" download>Download search.py</a>
        <a href="utils.py" download>Download utils.py</a>
    </div>

    <!-- Section to show results -->
    <div class="result-section">
        <h2>Results</h2>
        <p>Below are the images generated by the Python code:</p>
        
        <!-- Show processed image -->
        <h3>Processed Image (JPG, tif)</h3>
        <img src="jpeg/out_tobolsk.jpeg" alt="tobolsk">
        <img src="jpeg/out2_lady.jpeg" alt="lady">
        <img src="jpeg/out2_three_generations.jpeg" alt="three_generations">
        <img src="jpeg/out_icon.jpeg" alt="icon">
        <img src="jpeg/out2_emir.jpeg" alt="emir">
        <img src="jpeg/out3_church.jpeg" alt="church">
        <img src="jpeg/out2_sculpture.jpeg" alt="sculpture">
        <img src="jpeg/out2_train.jpeg" alt="train">
        <img src="jpeg/out_cathedral.jpeg" alt="cathedral">
        <img src="jpeg/out_monastery.jpeg" alt="monastery">
        <img src="jpeg/out_fname.jpeg" alt="portrait">
        <img src="jpeg/out_onion_church.jpeg" alt="onion_church">
        <img src="jpeg/out2_melons.jpeg" alt="melons">
    </div>

</body>
</html>


